// Generated by CoffeeScript 1.7.1
(function() {
  var Challenge, Ongoing, mangoose;

  Challenge = require("../app/models/challenge");

  Ongoing = require("../app/models/ongoing");

  mangoose = require('mongoose');

  module.exports = function(_, mailer, moment, genUID, users) {
    return {

      /*
      Create a new challenge
      @param  {array}   req  [form variables]
      @param  {Function} done [callback]
      @return {mixed}        [true or error]
       */
      create: function(req, done) {
        var data, description, durationD, durationH, game, newChallenge, title, uID, user;
        data = req.body;
        user = req.user;
        console.log(data["idGame"]);
        title = data["title"];
        durationH = data["durationH"];
        durationD = data["durationD"];
        description = data["description"];
        game = data["idGame"];
        uID = genUID.generate().substr(-6);
        console.log(game);
        newChallenge = new Challenge();
        newChallenge.idCool = uID;
        newChallenge.title = title;
        newChallenge.description = description;
        newChallenge.game = game;
        newChallenge.durationH = durationH;
        newChallenge.durationD = durationD;
        newChallenge.author = user._id;
        return newChallenge.save(function(err) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(newChallenge);
        });
      },

      /*
      Edit an existing challenge.
      @param  {array}   data [data which have to be updated]
      @param  {Function} done [callback]
      @return {mixed}        [true or error]
       */
      edit: function(data, done) {},

      /*
      Favorite a challenge.
      Most favorited challenge are highlighted
      @param  {array}   data [Challenge and user id]
      @param  {Function} done [description]
      @return {mixed}        [true or error]
       */
      favorite: function(data, done) {},

      /*
      User evaluation of an existing challenge
      Requiered: User already did this event
      @param  {array}   data [parameters and rate]
      @param  {Function} done [callback]
      @return {mixed}        [true or error]
       */
      rate: function(data, done) {},

      /*
      Delete a challenge
      @param  {Array}   data   [Id and user session]
      @param  {Function} done [description]
      @return {[type]}        [description]
       */
      "delete": function(data, done) {
        var currentUser;
        currentUser = data.user.local.email;

        /*
        Select the challenge and remove it from our model
         */
        return Challenge.find({
          _id: data.id
        }).limit(1).exec(function(err, doc) {
          var chall;
          if (err) {
            return done(err);
          }
          chall = doc[0];
          if (chall.author === currentUser) {
            return chall.remove(done);
          } else {
            return done(false, "you are not the owner of this challenge");
          }
        });
      },

      /*
      Return all the details for a given challenge
      @param  {String}   id   [id of the challenge]
      @param  {Function} done [callback]
      @return {Object}        [Object containing all the challenge data]
       */
      getList: function(safe, done) {
        var qs;
        if (safe === true) {
          qs = '-userRand -verfiy_hash -local.email -local.password -sessionKey -facebook.email -google.email -twitter.tokenSecret -notifications -sentRequests -pendingRequests -tribunal -tribunalHistoric -challengeRateHistoric';
        } else {
          qs = '';
        }
        return Challenge.find({}).populate('game completedBy author', qs).sort("-value -rateNumber").exec(function(err, data) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(data);
        });
      },

      /*
      Return all the details for a given challenge
      @param  {String}   id   [id of the challenge]
      @param  {Function} done [callback]
      @return {Object}        [Object containing all the challenge data]
       */
      getChallenge: function(id, safe, done) {
        var checkForHexRegExp, isObj, qs;
        checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
        isObj = checkForHexRegExp.test(id);
        if (safe === true) {
          qs = '-userRand -verfiy_hash -local.email -local.password -sessionKey -facebook.email -google.email -twitter.tokenSecret -notifications -sentRequests -pendingRequests -tribunal -tribunalHistoric -challengeRateHistoric';
        } else {
          qs = '';
        }
        if (isObj) {
          return Challenge.findById(id).select(qs).populate('author', qs).exec(function(err, data) {
            if (err) {
              mailer.cLog('Error at ' + __filename, err);
            }
            return done(data);
          });
        } else {
          return Challenge.findOne({
            idCool: id
          }).select(qs).populate('author', qs).exec(function(err, data) {
            if (err) {
              mailer.cLog('Error at ' + __filename, err);
            }
            return done(data);
          });
        }
      },
      completedBy: function(id, userArray, done) {
        return Challenge.findOneAndUpdate(id, {
          $addToSet: {
            completedBy: userArray
          }
        }).exec(function(err, challenge) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(true);
        });
      },

      /*
      [rateChallenge description]
      @param  {Object}   data [id String idCool, user ObjectId, difficulty Number, quickness Number, fun Number ]
      @param  {Function} done [callback]
      @return {Boolean}
       */
      rateChallenge: function(data, done) {
        return Challenge.findOne({
          idCool: data.id
        }).exec(function(err, challenge) {
          var averageDifficulty, averageQuick, averagefun, bonusUpdated, diff, diffiFive, diffiRate, difficultyCoeffs, fun, funCoeffs, funFive, funRate, newDiffiCount, newDiffiSum, newFunCount, newFunSum, newQuickCount, newQuickSum, ponderatedAvgDiff, ponderatedAvgFun, ponderatedAvgQuick, quick, quickFive, quickRate, quicknessCoeffs;
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          diff = challenge.rating.difficulty;
          diffiRate = data.difficulty;
          quick = challenge.rating.quickness;
          quickRate = data.quickness;
          fun = challenge.rating.fun;
          funRate = data.fun;
          diffiFive = Math.round(diffiRate / 10);
          quickFive = Math.round(quickRate / 10);
          funFive = Math.round(funRate / 10);
          diffiFive = (diffiFive < 1 ? 1 : diffiFive);
          quickFive = (quickFive < 1 ? 1 : quickFive);
          funFive = (funFive < 1 ? 1 : funFive);
          console.log(diffiFive + " o " + quickFive + " o " + funFive);
          newDiffiCount = (diff.count ? diff.count : 0) + 1;
          newDiffiSum = (diff.sum ? diff.sum : 0) + diffiRate;
          if (diffiRate > (diff.max ? diff.max : 0)) {
            diff.max = diffiRate;
          }
          if (diffiRate < (diff.min ? diff.min : 0)) {
            diff.min = diffiRate;
          }
          diff.sum = newDiffiSum;
          diff.avg = newDiffiSum / newDiffiCount;
          diff.count = newDiffiCount;
          switch (diffiFive) {
            case 1:
              diff.distribution.one = (diff.distribution.one ? diff.distribution.one : 0) + 1;
              break;
            case 2:
              diff.distribution.two = (diff.distribution.two ? diff.distribution.two : 0) + 1;
              break;
            case 3:
              diff.distribution.three = (diff.distribution.three ? diff.distribution.three : 0) + 1;
              break;
            case 4:
              diff.distribution.four = (diff.distribution.four ? diff.distribution.four : 0) + 1;
              break;
            case 5:
              diff.distribution.five = (diff.distribution.five ? diff.distribution.five : 0) + 1;
              break;
            default:
              mailer.cLog('Error at ' + __filename, 'error with switch for ' + diffiFive);
              console.log("error with switch for " + diffiFive);
          }
          newQuickCount = (quick.count ? quick.count : 0) + 1;
          newQuickSum = (quick.sum ? quick.sum : 0) + quickRate;
          if (quickRate > (quick.max ? quick.max : 0)) {
            quick.max = quickRate;
          }
          if (quickRate < (quick.min ? quick.min : 0)) {
            quick.min = quickRate;
          }
          quick.sum = newQuickSum;
          quick.avg = newQuickSum / newQuickCount;
          quick.count = newQuickCount;
          switch (quickFive) {
            case 1:
              quick.distribution.one = (quick.distribution.one ? quick.distribution.one : 0) + 1;
              break;
            case 2:
              quick.distribution.two = (quick.distribution.two ? quick.distribution.two : 0) + 1;
              break;
            case 3:
              quick.distribution.three = (quick.distribution.three ? quick.distribution.three : 0) + 1;
              break;
            case 4:
              quick.distribution.four = (quick.distribution.four ? quick.distribution.four : 0) + 1;
              break;
            case 5:
              quick.distribution.five = (quick.distribution.five ? quick.distribution.five : 0) + 1;
              break;
            default:
              mailer.cLog('Error at ' + __filename, 'error with switch for ' + quickFive);
              console.log("error with switch for " + quickFive);
          }
          newFunCount = (fun.count ? fun.count : 0) + 1;
          newFunSum = (fun.sum ? fun.sum : 0) + funRate;
          if (funRate > (fun.max ? fun.max : 0)) {
            fun.max = funRate;
          }
          if (funRate < (fun.min ? fun.min : 0)) {
            fun.min = funRate;
          }
          fun.sum = newFunSum;
          fun.avg = newFunSum / newFunCount;
          fun.count = newFunCount;
          switch (funFive) {
            case 1:
              fun.distribution.one = (fun.distribution.one ? fun.distribution.one : 0) + 1;
              break;
            case 2:
              fun.distribution.two = (fun.distribution.two ? fun.distribution.two : 0) + 1;
              break;
            case 3:
              fun.distribution.three = (fun.distribution.three ? fun.distribution.three : 0) + 1;
              break;
            case 4:
              fun.distribution.four = (fun.distribution.four ? fun.distribution.four : 0) + 1;
              break;
            case 5:
              fun.distribution.five = (fun.distribution.five ? fun.distribution.five : 0) + 1;
              break;
            default:
              mailer.cLog('Error at ' + __filename, 'error with switch for ' + funRate);
              console.log("error with switch for " + funRate);
          }
          difficultyCoeffs = [1.00, 1.40, 1.96, 2.74, 3.84];
          quicknessCoeffs = [2.67, 2.09, 1.64, 1.28, 1.00];
          funCoeffs = [1.00, 1.29, 1.72, 2.50, 4.12];
          ponderatedAvgDiff = (diff.distribution.one * difficultyCoeffs[0]) + (diff.distribution.two * difficultyCoeffs[1]) + (diff.distribution.three * difficultyCoeffs[2]) + (diff.distribution.four * difficultyCoeffs[3]) + (diff.distribution.five * difficultyCoeffs[4]);
          averageDifficulty = ponderatedAvgDiff / diff.count;
          ponderatedAvgQuick = (quick.distribution.one * quicknessCoeffs[0]) + (quick.distribution.two * quicknessCoeffs[1]) + (quick.distribution.three * quicknessCoeffs[2]) + (quick.distribution.four * quicknessCoeffs[3]) + (quick.distribution.five * quicknessCoeffs[4]);
          averageQuick = ponderatedAvgQuick / quick.count;
          ponderatedAvgFun = (fun.distribution.one * funCoeffs[0]) + (fun.distribution.two * funCoeffs[1]) + (fun.distribution.three * funCoeffs[2]) + (fun.distribution.four * funCoeffs[3]) + (fun.distribution.five * funCoeffs[4]);
          averagefun = ponderatedAvgFun / fun.count;
          bonusUpdated = Math.round((averageDifficulty + averageQuick + averagefun) * 1.61803398875);
          console.log("new averages d:" + averageDifficulty + " (" + ponderatedAvgDiff + "/" + diff.count + ") q:" + averageQuick + " (" + ponderatedAvgQuick + "/" + quick.count + ") f:" + averagefun + " (" + ponderatedAvgFun + "/" + fun.count + ") New bonus :" + bonusUpdated);
          challenge.value = bonusUpdated;
          challenge.rateNumber = challenge.rateNumber + 1;
          challenge.rateValue = Math.round((data.difficulty + data.quickness + data.fun) / 3);
          return challenge.save(function(err, result) {
            var obj, theChallenge, theNote;
            if (err) {
              mailer.cLog('Error at ' + __filename, err);
            }
            obj = {
              id: result._id,
              idUser: data.idUser,
              rating: {
                difficulty: data.difficulty,
                quickness: data.quickness,
                fun: data.fun
              }
            };
            theChallenge = result;
            theNote = Math.round((data.difficulty + data.quickness + data.fun) / 3);
            return users.ratedChallenge(obj, function(result) {
              var toNotify;
              toNotify = {
                challenge: theChallenge,
                note: theNote,
                user: result
              };
              return done(toNotify);
            });
          });
        });
      },

      /*
      Return all the challenges created byt a given user
      @param  {String}   email  [email of the creator]
      @param  {Function} done [callback]
      @return {Object}        [List of challenges]
       */
      getUserChallenges: function(id, done) {
        return Challenge.find({
          author: id
        }).populate("author").sort("-creation").exec(function(err, data) {
          if (err) {
            return done(err);
          }
          return done(data);
        });
      },

      /*
      Return a challenge's details
      @param  {ObjectId}   id  [idCool of the challenge]
      @param  {Function} done [callback]
      @return {Object}        [List of challenges]
       */
      ongoingDetails: function(id, done) {
        return Ongoing.findOne({
          idCool: id
        }).populate("_idChallenge _idChallenger _idChallenged").exec(function(err, data) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(data);
        });
      },

      /*
      Return the challenges accepted by a given user
      @param  {ObjectId}   id  [_id of the creator]
      @param  {Function} done [callback]
      @return {Object}        [List of challenges]
       */
      userAcceptedChallenge: function(id, safe, callback) {
        var qs;
        if (safe === true) {
          qs = '-userRand -verfiy_hash -local.email -local.password -sessionKey -facebook.email -google.email -twitter.tokenSecret -notifications -sentRequests -pendingRequests -tribunal -tribunalHistoric -challengeRateHistoric';
        } else {
          qs = '';
        }
        return Ongoing.find({
          accepted: true,
          $or: [
            {
              _idChallenger: id
            }, {
              _idChallenged: id
            }
          ]
        }).populate('_idChallenge _idChallenger _idChallenged').exec(function(err, data) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          console.log(data);
          return callback(data);
        });
      },

      /*
      Return all the challenges (request and received) for a given user
      @param  {ObjectId}   id  [_id of the creator]
      @param  {Function} done [callback]
      @return {Object}        [List of challenges]
       */
      challengerRequests: function(id, done) {
        return Ongoing.find({
          _idChallenger: id
        }).populate("_idChallenge _idChallenger _idChallenged").exec(function(err, data) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(data);
        });
      },

      /*
      Return all the challenges (request and received) for a given user
      @param  {ObjectId}   id  [_id of the creator]
      @param  {Function} done [callback]
      @return {Object}        [List of challenges]
       */
      challengedRequests: function(id, done) {
        return Ongoing.find({
          _idChallenged: id
        }).populate("_idChallenge _idChallenger _idChallenged").exec(function(err, data) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(data);
        });
      },

      /*
      Challenge another user !
      @param  {Object}   data [All the required data to throw a challenge]
      @param  {Function} done [description]
      @return {[type]}        [description]
       */
      launch: function(data, done) {
        var oCha, query;
        if (data.deadLine.d > 0) {
          query = {
            hours: data.deadLine.h,
            days: data.deadLine.d
          };
        } else {
          query = {
            hours: data.deadLine.h
          };
        }
        oCha = new Ongoing();
        oCha._idChallenge = data.idChallenge;
        oCha._idChallenger = data.from;
        oCha._idChallenged = data.idChallenged;
        oCha.idCool = genUID.generate().substr(-6);
        oCha.launchDate = moment(data.launchDate).utc();
        oCha.deadLine = moment(data.launchDate).utc().add(query);
        return oCha.save(function(err) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(oCha);
        });
      },

      /*
      accept an ongoing challenge's request, setting "accepted" to true
      @param  {Object}   data [id challenge and id of user]
      @param  {Function} done [callback]
      @return {Boolean}       [true or false]
       */
      accept: function(data, done) {
        var idChallenge, idUser;
        idChallenge = data.id;
        idUser = data.idUser;

        /*
        Select the challenge and remove it from our model
         */
        return Ongoing.findOne({
          _id: idChallenge
        }).populate("_idChallenge _idChallenged _idChallenger").exec(function(err, chall) {
          var passing, testiD, uString;
          passing = chall;
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          testiD = chall._idChallenged._id.toString();
          uString = idUser.toString();
          console.log(testiD + " " + uString);
          if (testiD === uString) {
            chall.accepted = true;
            return chall.save(function(err) {
              if (err) {
                mailer.cLog('Error at ' + __filename, err);
              }
              return done(passing);
            });
          } else {
            return done(false, "you are not the person challenged on this challenge");
          }
        });
      },

      /*
      Deny an ongoing challenge's request by deleting it.
      @param  {Object}   data [id challenge and id of user]
      @param  {Function} done [callback]
      @return {Boolean}       [true or false]
       */
      deny: function(data, done) {
        var idChallenge, idUser;
        idChallenge = data.id;
        idUser = data.idUser;
        return Ongoing.findOne({
          _id: idChallenge
        }).exec(function(err, chall) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          console.log(chall._idChallenged + " <> " + idUser);
          console.log(chall._idChallenged.toString() === idUser.toString());
          if (chall._idChallenged.toString() === idUser.toString()) {
            chall.remove();
            return done(true);
          } else {
            return done(false, "you are not the person challenged on this challenge");
          }
        });
      },
      requestValidation: function(data, done) {
        return Ongoing.findOne({
          _id: data.idChallenge,
          _idChallenged: data.idUser
        }).populate("_idChallenge _idChallenged _idChallenger").exec(function(err, ongoing) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          ongoing.waitingConfirm = true;
          ongoing.confirmAsk = new Date;
          ongoing.confirmLink1 = data.proofLink1;
          ongoing.confirmLink2 = (data.proofLink2 ? data.proofLink2 : "");
          ongoing.confirmComment = (data.confirmComment ? data.confirmComment : "");
          return ongoing.save(function(err) {
            if (err) {
              mailer.cLog('Error at ' + __filename, err);
            }
            return done(ongoing);
          });
        });
      },

      /*
      A challenge has reached or crossed its deadline, invalidate it.
      @param  {[type]} challenge [description]
      @return {[type]}           [description]
       */
      crossedDeadline: function(challenge) {
        return Ongoing.findByIdAndUpdate(challenge, {
          waitingConfirm: false,
          validated: false,
          progress: 100,
          crossedDeadline: true
        }).exec(function(err, done) {
          if (err) {
            console.log(err);
          }
          return true;
        });
      },

      /*
      [validateOngoing description]
      @param  {Object}   data [oId : req.params.id, deny : req.body.deny]
      @param  {Function} done [description]
      @return {[type]}        [description]
       */
      validateOngoing: function(data, done) {
        var self;
        self = this;
        return Ongoing.findOne({
          idCool: data.oId
        }).populate("_idChallenged _idChallenger _idChallenge").exec(function(err, ongoing) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          ongoing.waitingConfirm = false;
          ongoing.validated = data.pass;
          ongoing.progress = 100;
          return ongoing.save(function(err) {
            var completedByArr;
            if (err) {
              mailer.cLog('Error at ' + __filename, err);
            }
            completedByArr = [ongoing._idChallenged._id];
            return self.completedBy(ongoing._idChallenge._id, completedByArr, function(result) {
              return done(ongoing);
            });
          });
        });
      },

      /*
      [userWaitingCases description]
      @param  {[type]}   user [description]
      @param  {Function} done [description]
      @return {[type]}        [description]
       */
      userWaitingCases: function(user, done) {
        var loadCases;
        loadCases = user.tribunal;
        return Ongoing.find({
          _id: {
            $in: loadCases
          }
        }).populate("_idChallenge _idChallenger _idChallenged").exec(function(err, cases) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(cases);
        });
      },

      /*
      Send an Ongoing event (actually closed) to the tribunal
      @param  {Object}   data [oId]
      @param  {Function} done [description]
      @return {[type]}        [description]
       */
      sendTribunal: function(data, done) {
        return Ongoing.findById(data.id).populate('_idChallenged _idChallenger _idChallenge').exec(function(err, ongoing) {
          var exclude;
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          if (ongoing.tribunal === false) {
            if (data.idUser.toString() === ongoing._idChallenged.toString()) {
              exclude = {
                one: ongoing._idChallenger,
                two: ongoing._idChallenged
              };
              return users.pickTribunalUsers(exclude, 3, function(pickedUser) {
                return users.setJudges(ongoing._id, pickedUser, function(completed) {
                  var aJudge, i, judges;
                  if (completed) {
                    judges = [];
                    i = pickedUser.length - 1;
                    while (i >= 0) {
                      aJudge = {
                        idUser: pickedUser[i]._id,
                        hasVoted: false,
                        answer: false
                      };
                      judges.push(aJudge);
                      i--;
                    }
                    ongoing.tribunal = true;
                    ongoing.tribunalVote = judges;
                    return ongoing.save(function(err, result) {
                      if (err) {
                        mailer.cLog('Error at ' + __filename, err);
                      }
                      return done(ongoing);
                    });
                  } else {
                    return mailer.cLog('Error at ' + __filename, "something went wrong here");
                  }
                });
              });
            } else {
              return done(false, "Case already taken in account");
            }
          } else {
            return done(false, "not the challenged");
          }
        });
      },

      /*
      Register a vote on a tribunal case given by an user
      @param  {Object}   data [id (String; idCool of an Ongoing), idUser(ObjectId), answer(Boolean)]
      @param  {Function} done [callback]
      @return {Boolean}
       */
      voteCase: function(data, done) {
        return Ongoing.findOneAndUpdate({
          idCool: data.id,
          "tribunalVote.idUser": data.idUser
        }, {
          $set: {
            "tribunalVote.$.answer": data.answer,
            "tribunalVote.$.hasVoted": true,
            "tribunalVote.$.voteDate": new Date
          }
        }).exec(function(err, cases) {
          var userData;
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          userData = {
            id: cases._id,
            idUser: data.idUser,
            answer: data.answer
          };
          console.log("Challenge.js l.673 - " + userData);
          return users.votedOnCase(userData, function(ret) {
            return done(cases);
          });
        });
      },
      completeCase: function(idCase, done) {
        return Ongoing.findOne({
          idCool: idCase
        }).populate("_idChallenged _idChallenger _idChallenge").exec(function(err, cases) {
          var deny, i, judges, validate;
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          deny = 0;
          validate = 0;
          judges = cases.tribunalVote;
          i = judges.length - 1;
          while (i >= 0) {
            if (judges[i].hasVoted === true) {
              if (judges[i].answer === true) {
                validate++;
              } else {
                deny++;
              }
            }
            i--;
          }
          console.log(("case: " + cases.idCool + " === [" + validate + "]+1 [" + deny + "]-1 Result: " + (validate > deny) ? "validated" : "denied"));
          cases.tribunalAnswered = (validate > deny ? true : false);
          cases.caseClosed = true;
          cases.caseClosedDate = new Date;
          return cases.save(function(err) {
            if (err) {
              mailer.cLog('Error at ' + __filename, err);
            }
            return done(cases);
          });
        });
      },
      remainingCaseVotes: function(idCase, done) {
        return Ongoing.findOne({
          idCool: idCase
        }).exec(function(err, req) {
          var counter, i, judges;
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          counter = 0;
          judges = req.tribunalVote;
          i = judges.length - 1;
          while (i >= 0) {
            if (judges[i].hasVoted === false) {
              counter++;
            }
            i--;
          }
          return done(counter);
        });
      }
    };
  };

}).call(this);
