// Generated by CoffeeScript 1.7.1
(function() {
  var Badge, Challenge, User;

  User = require("../app/models/user");

  Badge = require("../app/models/badge");

  Challenge = require("../app/models/challenge");

  module.exports = function(_, mailer, appKeys, genUID, social, relations, notifs, moment) {
    return {
      validateEmail: function(hash, done) {
        return User.findOne({
          verfiy_hash: hash
        }, function(err, user) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          if (user) {
            user.verified = true;
            return user.save(function(err) {
              if (err) {
                mailer.cLog('Error at ' + __filename, err);
              }
              return done(user);
            });
          } else {
            return done(false);
          }
        });
      },
      retrievePassword: function(email, done) {
        return User.findOne({
          'local.email': email
        }, function(err, user) {
          var password;
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          password = genUID.generate();
          user.local.password = user.generateHash(password);
          return user.save(function(err, user) {
            if (err) {
              mailer.cLog('Error at ' + __filename, err);
            }
            mailer.sendMail(user, '[Cyf]Your password has been reseted', '<h2>New Password</h2> <p>At your request we have generated a new password for your.</p><p> Your news credentials: <ul><li>email:<strong>' + user.local.email + '</strong></li><li>password: <strong> ' + password + '</strong></li></p><p>You can login here: <a href="http://www.cyf-app.co/login" target="_blank" title="Login">http://www.cyf-app.co/login</a></p><p><strong> You are the only person who have this information, if you want a new password, please reset it through the same procedure.</strong></p>', false);
            return done(true);
          });
        });
      },
      changePassword: function(user, newPwd, done) {
        return User.findById(user._id, function(err, user) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          user.local.password = user.generateHash(newPwd);
          return user.save(function(err, user) {
            if (err) {
              mailer.cLog('Error at ' + __filename, err);
            }
            mailer.sendMail(user, '[Cyf]Your password has been changed!', '<h2>You have changed your Password</h2> <p>We send you this mail to confirm that your password has been updated successfully.</p><p> Your news credentials: <ul><li>email:<strong> ' + user.local.email + '</strong></li><li>password:<strong> ' + newPwd + '</strong></li></p><p>You can login here: <a href="http://www.cyf-app.co/login" target="_blank" title="Login">http://www.cyf-app.co/login</a></p><p><strong> You are the only person who have this information, if you want a new password, please reset it through the same procedure.</strong></p>', false);
            return done(true);
          });
        });
      },
      removeGames: function(user, id, done) {
        return User.findByIdAndUpdate(user._id, {
          $pull: {
            games: {
              _id: id
            }
          }
        }).exec(function(err, user) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          if (err) {
            done(false);
          }
          return done(true);
        });
      },
      addPlayedGames: function(user, ng, done) {
        var buff, dT, dl, query, tei, test;
        if (ng._id) {
          dT = user.games;
          dl = ng._id;
          tei = [];
          _.each(user.games, function(game) {
            return tei.push(game._idGame.toString());
          });
          test = tei.indexOf(ng._id.toString(dl));
          if (test === -1) {
            buff = {
              _idGame: ng._id,
              title: ng.title,
              type: ng.type
            };
            query = {
              $push: {
                games: buff
              }
            };
            return User.findByIdAndUpdate(user._id, query, function(err, user) {
              if (err) {
                mailer.cLog('Error at ' + __filename, err);
              }
              return done(true);
            });
          } else {
            return done(false);
          }
        } else {
          return done(false);
        }
      },
      fbInvites: function(data, done) {
        var friends, query;
        friends = data.fbInvitedFriends;
        query = {
          $pushAll: {
            fbInvitedFriends: friends
          }
        };
        return User.findByIdAndUpdate(data.id, query, function(err, user) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          console.log(user.fbInvitedFriends);
          return done(true);
        });
      },
      updateSettings: function(data, done) {
        var query;
        query = void 0;
        if (data.target === "facebook" || data.target === "twitter") {
          if (data.target === "facebook") {
            query = {
              $set: {
                "share.facebook": data.value
              }
            };
          } else {
            query = {
              $set: {
                "share.twitter": data.value
              }
            };
          }
          return User.findByIdAndUpdate(data._id, query, function(err) {
            if (err) {
              mailer.cLog('Error at ' + __filename, err);
            }
            return done(true);
          });
        } else {
          return done(false);
        }
      },
      populateProfile: function(id, done) {
        return User.findById(id).populate('friends.idUser badges.idBadge', '-notifications').exec(function(err, user) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(user);
        });
      },
      getFriendList: function(id, done) {
        return User.findById(id).populate({
          path: 'friends.idUser',
          select: '-notifications'
        }).exec(function(err, user) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(user);
        });
      },
      getBadgesList: function(id, done) {
        return User.findById(id).populate({
          path: 'badges.idBadge'
        }).exec(function(err, user) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(user);
        });
      },
      setOffline: function(user, done) {
        return User.findByIdAndUpdate(user._id, {
          isOnline: false
        }, function(err) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(true);
        });
      },

      /*
      Return NUMBER users whom will be used as judge in the tribunal
      for a given ongoing case.
      @param  {Object}   exclude [_id of users to exclude: the challenger and challenged]
      @param  {Number}   number  [number of judges we want]
      @param  {Function} done    [callback]
      @return {Array}           [Array of users' object]
       */
      pickTribunalUsers: function(exclude, number, done) {
        var nearNum, num;
        num = (number ? number : 1);
        nearNum = [Math.random(), 0];
        User.find({
          $and: [
            {
              _id: {
                $ne: exclude.one
              }
            }, {
              _id: {
                $ne: exclude.two
              }
            }
          ],
          userRand: {
            $near: nearNum
          }
        }).limit(num).exec(function(err, randomUser) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(randomUser);
        });
      },
      setJudges: function(id, users, done) {
        var i, query;
        query = [];
        i = users.length - 1;
        while (i >= 0) {
          query.push(users[i]._id);
          i--;
        }
        User.update({
          _id: {
            $in: query
          }
        }, {
          $addToSet: {
            tribunal: id
          }
        }, {
          multi: true
        }).exec(function(err, randomUser) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(true);
        });
      },

      /*
      Delete the ongoing Case and add an item in the tribunalHistoric
      @param  {[type]}   data [description]
      @param  {Function} done [description]
      @return {[type]}        [description]
       */
      votedOnCase: function(data, done) {
        var currentDate, idSplice, query;
        query = [];
        currentDate = new Date();
        idSplice = data.id;
        return User.findByIdAndUpdate(data.idUser, {
          $push: {
            tribunalHistoric: {
              idCase: data.id,
              answer: data.answer,
              voteDate: currentDate
            }
          }
        }).exec(function(err, doc) {
          var idx;
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          idx = (doc.tribunal ? doc.tribunal.indexOf(idSplice) : -1);
          if (idx !== -1) {
            doc.tribunal.splice(idx, 1);
            return doc.save(function(err, doc) {
              if (err) {
                mailer.cLog('Error at ' + __filename, err);
              }
              return done(true);
            });
          } else {
            if (err) {
              mailer.cLog('Error at ' + __filename, err);
            }
            return done('Error when slicing');
          }
        });
      },
      getUsers: function(limit, done) {
        return User.find({}).sort("-_id").limit(limit).exec(function(err, data) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(data);
        });
      },

      /*
      Return the list of existing users
      @param  {String} arg    [(optional) parameters]
      @param  {[type]} return [description]
      @return {[type]}        [description]
       */
      getUserList: function(safe, done) {
        var qs;
        if (safe === true) {
          qs = '-userRand -verfiy_hash -local.email -local.password -sessionKey -facebook.email -google.email -twitter.tokenSecret -notifications -sentRequests -pendingRequests -tribunal -tribunalHistoric -challengeRateHistoric';
        } else {
          qs = '';
        }
        return User.find({}).select(qs).sort("_id").exec(function(err, data) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(data);
        });
      },

      /*
      Return the result of a given query for the user model
      @param  {String} arg    [(optional) parameters]
      @param  {[type]} return [description]
      @return {[type]}        [description]
       */
      getUser: function(id, safe, done) {
        var checkForHexRegExp, isObj, qs;
        checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
        isObj = checkForHexRegExp.test(id);
        if (safe === true) {
          qs = '-userRand -verfiy_hash -local.email -local.password -sessionKey -facebook.email -google.email -twitter.tokenSecret -notifications -sentRequests -pendingRequests -tribunal -tribunalHistoric -challengeRateHistoric';
        } else {
          qs = '';
        }
        if (isObj) {
          return User.findById(id).select(qs).populate({
            path: 'friends.idUser',
            select: qs
          }).exec(function(err, data) {
            if (err) {
              mailer.cLog('Error at ' + __filename, err);
            }
            return done(data);
          });
        } else {
          return User.findOne({
            idCool: id
          }).select(qs).populate({
            path: 'friends.idUser',
            select: qs
          }).exec(function(err, data) {
            if (err) {
              mailer.cLog('Error at ' + __filename, err);
            }
            return done(data);
          });
        }
      },

      /*
      Request a friendship with another user
      @param  {Object}   data [From, id, to, id]
      @param  {Function} done [callback]
      @return {Boolean}        [true/false]
       */
      askFriend: function(data, done) {
        var from, uTo;
        from = data.from;
        uTo = data.to;
        return User.findById(uTo.id).exec(function(err, data) {
          var currentDate;
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          currentDate = new Date;
          if (data) {
            return relations.create(from, uTo, true, function(result) {
              return relations.create(uTo, from, false, function(result) {
                return done(data);
              });
            });
          } else {
            return done(false, " desired user not found");
          }
        });
      },

      /*
      Delete the rate request and add an item in challengeRateHistoric
      @param  {[type]}   data [description]
      @param  {Function} done [description]
      @return {[type]}        [description]
       */
      ratedChallenge: function(data, done) {
        var currentDate, idSplice, query;
        query = [];
        currentDate = new Date();
        idSplice = data.id;
        User.findByIdAndUpdate(data.idUser, {
          $push: {
            challengeRateHistoric: {
              _idChallenge: data.id,
              rateDate: currentDate,
              rating: data.rating
            }
          }
        }).exec(function(err, doc) {
          var idx;
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          idx = (doc.challengeRate ? doc.challengeRate.indexOf(idSplice) : -1);
          if (idx !== -1) {
            doc.challengeRate.splice(idx, 1);
            doc.save(function(err, doc) {
              if (err) {
                mailer.cLog('Error at ' + __filename, err);
              }
              return done(doc);
            });
            return;
          }
          return done(false, "wrong whilst splicing. users l.280");
        });
      },

      /*
      Ask users to review the challenge they've just done.
      @param  {Object}   idChallenge [id : _idChallenge (Object),idChallenged (Object),idChallenger (Object)]
      @param  {Function} done        [description]
      @return {[type]}               [description]
       */
      askRate: function(data, done) {
        var query;
        query = [data._idChallenger, data._idChallenged];
        User.update({
          _id: {
            $in: query
          }
        }, {
          $addToSet: {
            challengeRate: data.id
          }
        }, {
          multi: true
        }).exec(function(err, user) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(true);
        });
      },
      userToRateChallenges: function(idUser, done) {
        return User.findById(idUser).populate("challengeRate").exec(function(err, data) {
          if (err) {
            return done(err);
          }
          return done(data);
        });
      },
      linkLol: function(data, done) {
        var UID, name, region;
        region = data.region;
        name = data.summonerName;
        UID = data.id;
        return social.findSummonerLol(region, name, function(summoner) {
          var lol;
          if (summoner.id) {
            lol = {
              idProfile: parseInt(summoner.id, 10),
              name: summoner.name,
              region: region,
              profileIconId: parseInt(summoner.profileIconId, 10),
              revisionDate: new Date(summoner.revisionDate * 1000),
              summonerLevel: parseInt(summoner.summonerLevel, 10),
              profileIconId_confirm: 0
            };
            return User.findByIdAndUpdate(UID, {
              leagueoflegend: lol
            }, function(err, user) {
              if (err) {
                mailer.cLog('Error at ' + __filename, err);
              }
              return done(true);
            });
          } else {
            return done(false, "summoner not found");
          }
        });
      },
      linkLolIconPick: function(data, done) {
        var UID, icon;
        UID = data.id;
        icon = parseInt(data.profileIconId_confirm, 10);
        return User.findByIdAndUpdate(UID, {
          'leagueoflegend.profileIconId_confirm': icon
        }, function(err, user) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(true);
        });
      },
      linkLol_confirm: function(user, done) {
        var UID, name, region;
        region = user.leagueoflegend.region;
        name = user.leagueoflegend.name;
        UID = user._id;
        return social.findSummonerLol(region, name, function(summoner) {
          console.log(summoner.profileIconId.toString() + ' === ' + user.leagueoflegend.profileIconId_confirm.toString());
          if (summoner.profileIconId.toString() === user.leagueoflegend.profileIconId_confirm.toString()) {
            mailer.cLog('linkLol attempt passed for  ' + user.local.pseudo, summoner.profileIconId + ' == ' + user.leagueoflegend.profileIconId_confirm);
            return User.findByIdAndUpdate(UID, {
              'leagueoflegend.confirmed': true
            }, function(err, user) {
              if (err) {
                mailer.cLog('Error at ' + __filename, err);
              }
              return done(true);
            });
          } else {
            mailer.cLog('linkLol attempt failed for  ' + user.local.pseudo, summoner.profileIconId + ' == ' + user.leagueoflegend.profileIconId_confirm);
            return done("Icons did not match!");
          }
        });
      },

      /*
      Unlink a league of legend account
      @param  {[type]}   user [description]
      @param  {Function} done [description]
      @return {[type]}        [description]
       */
      unlinkLol: function(id, done) {
        return User.findById(id).exec(function(err, user) {
          var lol;
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          lol = user.leagueoflegend;
          lol.idProfile = undefined;
          lol.name = undefined;
          lol.profileIconId = undefined;
          lol.revisionDate = undefined;
          lol.summonerLevel = undefined;
          return user.save(function(err) {
            if (err) {
              mailer.cLog('Error at ' + __filename, err);
            }
            return done(true);
          });
        });
      },

      /*
      Unlink a league of legend account
      @param  {[type]}   user [description]
      @param  {Function} done [description]
      @return {[type]}        [description]
       */
      updateLastGames: function(user, done) {
        var UID, championsList;
        UID = user._id;
        if (user.leagueoflegend.confirmed === true) {
          championsList = social.lol_champion_list();
          return social.getLastGames(user.leagueoflegend.region, user.leagueoflegend.idProfile, function(last10) {
            var test, uGl;
            uGl = user.leagueoflegend.lastGames.length;
            test = uGl === 0 || user.leagueoflegend.lastGames[uGl - 1].gameId !== last10[last10.length - 1].gameId;
            console.log(test);
            if (test === true) {
              return User.findById(UID).exec(function(err, user) {
                if (err) {
                  mailer.cLog('Error at ' + __filename, err);
                }
                if (!user.leagueoflegend.lastGames) {
                  user.leagueoflegend.lastGames = [];
                }
                _.each(last10, function(game) {
                  var aGame, champ, g;
                  g = game;
                  champ = _.find(championsList, function(champ) {
                    return champ.id === g.championId;
                  });
                  console.log(champ);
                  aGame = {
                    championId: g.championId,
                    championInfos: champ,
                    createDate: moment(g.createDate).utc().format('dddd DD MMMM HH[h]mm'),
                    fellowPlayers: [game.fellowPlayers],
                    gameId: g.gameId,
                    gameMode: g.gameMode,
                    gameType: g.gameType,
                    invalid: g.invalid,
                    ipEarned: g.ipEarned,
                    level: g.level,
                    mapId: g.mapId,
                    spell1: g.spell1,
                    spell2: g.spell2,
                    stats: g.stats,
                    subType: g.subType,
                    teamId: g.teamId
                  };
                  return user.leagueoflegend.lastGames.push(aGame);
                });
                return user.save(function(err) {
                  if (err) {
                    mailer.cLog('Error at ' + __filename, err);
                  }
                  return done(true);
                });
              });
            } else {
              return done(false, 'already up to date');
            }
          });
        } else {
          return done(false, 'link an account firstly');
        }
      }
    };
  };

}).call(this);
