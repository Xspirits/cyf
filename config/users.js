// Generated by CoffeeScript 1.7.1
(function() {
  var Challenge, User, appKeys, mailer, mandrill, mandrill_client, moment, nodemailer, notifs, relations, social, _;

  appKeys = require("./auth");

  User = require("../app/models/user");

  Challenge = require("../app/models/challenge");

  notifs = require("../app/functions/notifications");

  relations = require("./relations");

  social = require("./social");

  _ = require("underscore");

  moment = require("moment");

  moment = require('moment-timezone');

  mandrill = require('mandrill-api/mandrill');

  nodemailer = require("nodemailer");

  moment().tz("Europe/London").format();

  mandrill_client = new mandrill.Mandrill(appKeys.mandrill_key);

  mailer = require("./mailer")(mandrill_client, nodemailer, appKeys, moment);

  module.exports = {
    validateEmail: function(hash, done) {
      return User.findOne({
        verfiy_hash: hash
      }, function(err, user) {
        if (err) {
          mailer.cLog('Error at ' + __filename, err);
        }
        if (user) {
          user.verified = true;
          user.save(function(err) {
            if (err) {
              mailer.cLog('Error at ' + __filename, err);
            }
            console.log(user);
            return done(user);
          });
        } else {
          done(false);
        }
      });
    },
    updateSettings: function(data, done) {
      var query;
      query = void 0;
      if (data.target === "facebook" || data.target === "twitter") {
        if (data.target === "facebook") {
          query = {
            $set: {
              "share.facebook": data.value
            }
          };
        } else {
          query = {
            $set: {
              "share.twitter": data.value
            }
          };
        }
        console.log(query);
        User.findByIdAndUpdate(data._id, query, function(err) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          done(true);
        });
      } else {
        done(false);
      }
    },
    getFriendList: function(id, done) {
      return User.findById(id).populate({
        path: 'friends.idUser',
        select: '-notifications'
      }).exec(function(err, user) {
        if (err) {
          mailer.cLog('Error at ' + __filename, err);
        }
        console.log(user);
        return done(user);
      });
    },
    linkLol: function(data, done) {
      var UID, name, region;
      region = data.region;
      name = data.summonerName;
      UID = data.id;
      return social.findSummonerLol(region, name, function(summoner) {
        var lol;
        if (summoner.id) {
          lol = {
            idProfile: parseInt(summoner.id, 10),
            name: summoner.name,
            region: region,
            profileIconId: parseInt(summoner.profileIconId, 10),
            revisionDate: new Date(summoner.revisionDate * 1000),
            summonerLevel: parseInt(summoner.summonerLevel, 10),
            profileIconId_confirm: 0
          };
          console.log(lol);
          return User.findByIdAndUpdate(UID, {
            leagueoflegend: lol
          }, function(err, user) {
            if (err) {
              throw err;
            }
            console.log(user);
            return done(true);
          });
        } else {
          return done(false, "summoner not found");
        }
      });
    },
    linkLolIconPick: function(data, done) {
      var UID, icon;
      UID = data.id;
      icon = parseInt(data.profileIconId_confirm, 10);
      return User.findByIdAndUpdate(UID, {
        'leagueoflegend.profileIconId_confirm': icon
      }, function(err, user) {
        if (err) {
          throw err;
        }
        return done(true);
      });
    },
    linkLol_confirm: function(user, done) {
      var UID, name, region;
      region = user.leagueoflegend.region;
      name = user.leagueoflegend.name;
      UID = user._id;
      return social.findSummonerLol(region, name, function(summoner) {
        console.log(summoner.profileIconId + ' == ' + user.leagueoflegend.profileIconId_confirm);
        mailer.cLog('linkLol attempt for  ' + user.local.pseudo, summoner.profileIconId + ' == ' + user.leagueoflegend.profileIconId_confirm);
        if (summoner.profileIconId === user.leagueoflegend.profileIconId_confirm) {
          return User.findByIdAndUpdate(UID, {
            'leagueoflegend.confirmed': true
          }, function(err, user) {
            if (err) {
              throw err;
            }
            return done(true);
          });
        } else {
          return done("Icons did not match!");
        }
      });
    },

    /*
    Unlink a league of legend account
    @param  {[type]}   user [description]
    @param  {Function} done [description]
    @return {[type]}        [description]
     */
    unlinkLol: function(id, done) {
      User.findById(id).exec(function(err, user) {
        var lol;
        if (err) {
          mailer.cLog('Error at ' + __filename, err);
        }
        lol = user.leagueoflegend;
        lol.idProfile = undefined;
        lol.name = undefined;
        lol.profileIconId = undefined;
        lol.revisionDate = undefined;
        lol.summonerLevel = undefined;
        user.save(function(err) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          console.log(user);
          return done(true);
        });
      });
    },
    setOffline: function(user, done) {
      User.findByIdAndUpdate(user._id, {
        isOnline: false
      }, function(err) {
        if (err) {
          mailer.cLog('Error at ' + __filename, err);
        }
        done(true);
      });
    },

    /*
    Return NUMBER users whom will be used as judge in the tribunal
    for a given ongoing case.
    @param  {Object}   exclude [_id of users to exclude: the challenger and challenged]
    @param  {Number}   number  [number of judges we want]
    @param  {Function} done    [callback]
    @return {Array}           [Array of users' object]
     */
    pickTribunalUsers: function(exclude, number, done) {
      var nearNum, num;
      num = (number ? number : 1);
      nearNum = [Math.random(), 0];
      User.find({
        $and: [
          {
            _id: {
              $ne: exclude.one
            }
          }, {
            _id: {
              $ne: exclude.two
            }
          }
        ],
        userRand: {
          $near: nearNum
        }
      }).limit(num).exec(function(err, randomUser) {
        if (err) {
          mailer.cLog('Error at ' + __filename, err);
        }
        return done(randomUser);
      });
    },
    setJudges: function(id, users, done) {
      var i, query;
      query = [];
      i = users.length - 1;
      while (i >= 0) {
        query.push(users[i]._id);
        i--;
      }
      console.log(query);
      User.update({
        _id: {
          $in: query
        }
      }, {
        $addToSet: {
          tribunal: id
        }
      }, {
        multi: true
      }).exec(function(err, randomUser) {
        if (err) {
          mailer.cLog('Error at ' + __filename, err);
        }
        return done(true);
      });
    },

    /*
    Delete the ongoing Case and add an item in the tribunalHistoric
    @param  {[type]}   data [description]
    @param  {Function} done [description]
    @return {[type]}        [description]
     */
    votedOnCase: function(data, done) {
      var currentDate, idSplice, query;
      query = [];
      currentDate = new Date();
      idSplice = data.id;
      User.findByIdAndUpdate(data.idUser, {
        $push: {
          tribunalHistoric: {
            idCase: data.id,
            answer: data.answer,
            voteDate: currentDate
          }
        }
      }).exec(function(err, doc) {
        var idx;
        if (err) {
          mailer.cLog('Error at ' + __filename, err);
        }
        console.log(doc);
        idx = (doc.tribunal ? doc.tribunal.indexOf(idSplice) : -1);
        if (idx !== -1) {
          doc.tribunal.splice(idx, 1);
          doc.save(function(err, doc) {
            if (err) {
              throw err;
            } else {
              done(true);
            }
          });
          return;
        }
        throw "wrong whilst splicing";
      });
    },
    getUsers: function(limit, done) {
      return User.find({}).sort("-_id").limit(limit).exec(function(err, data) {
        if (err) {
          mailer.cLog('Error at ' + __filename, err);
        }
        return done(data);
      });
    },

    /*
    Return the list of existing users
    @param  {String} arg    [(optional) parameters]
    @param  {[type]} return [description]
    @return {[type]}        [description]
     */
    getUserList: function(done) {
      return User.find({}).sort("-_id").exec(function(err, data) {
        if (err) {
          mailer.cLog('Error at ' + __filename, err);
        }
        return done(data);
      });
    },

    /*
    Return the result of a given query for the user model
    @param  {String} arg    [(optional) parameters]
    @param  {[type]} return [description]
    @return {[type]}        [description]
     */
    getUser: function(id, done) {
      var checkForHexRegExp, isObj;
      checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
      isObj = checkForHexRegExp.test(id);
      console.log(isObj);
      if (isObj) {
        return User.findById(id).populate("friends.idUser").exec(function(err, data) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(data);
        });
      } else {
        return User.findOne({
          idCool: id
        }).populate("friends.idUser").exec(function(err, data) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(data);
        });
      }
    },

    /*
    Request a friendship with another user
    @param  {Object}   data [From, id, to, id]
    @param  {Function} done [callback]
    @return {Boolean}        [true/false]
     */
    askFriend: function(data, done) {
      var from, uTo;
      from = data.from;
      uTo = data.to;
      return User.findById(uTo.id).exec(function(err, data) {
        var currentDate;
        if (err) {
          mailer.cLog('Error at ' + __filename, err);
        }
        currentDate = new Date;
        if (data) {
          return relations.create(from, uTo, true, function(result) {
            return relations.create(uTo, from, false, function(result) {
              return done(data);
            });
          });
        } else {
          return done(false, " desired user not found");
        }
      });
    },

    /*
    Confirm a friend relationship with another user
    @param  {Object}   data [From, id, to, id]
    @param  {Function} done [callback]
    @return {Boolean}        [true/false]
     */
    confirmFriend: function(data, done) {
      var from, uTo;
      from = data.from;
      uTo = data.to;
      relations.accept(from, uTo, function(result) {
        if (result) {
          relations.accept(uTo, from, done);
        }
      });
    },

    /*
    Confirm a friend relationship with another user
    @param  {Object}   data [From, id, to, id]
    @param  {Function} done [callback]
    @return {Boolean}        [true/false]
     */
    denyFriend: function(data, done) {
      var from, uTo;
      from = data.from;
      uTo = data.to;
      relations.deny(from, uTo, function(result) {
        if (result) {
          relations.deny(uTo, from, done);
        }
      });
    },

    /*
    Delete the rate request and add an item in challengeRateHistoric
    @param  {[type]}   data [description]
    @param  {Function} done [description]
    @return {[type]}        [description]
     */
    ratedChallenge: function(data, done) {
      var currentDate, idSplice, query;
      query = [];
      currentDate = new Date();
      idSplice = data.id;
      User.findByIdAndUpdate(data.idUser, {
        $push: {
          challengeRateHistoric: {
            _idChallenge: data.id,
            rateDate: currentDate,
            rating: data.rating
          }
        }
      }).exec(function(err, doc) {
        var idx;
        if (err) {
          mailer.cLog('Error at ' + __filename, err);
        }
        idx = (doc.challengeRate ? doc.challengeRate.indexOf(idSplice) : -1);
        if (idx !== -1) {
          doc.challengeRate.splice(idx, 1);
          doc.save(function(err, doc) {
            if (err) {
              throw err;
            } else {
              done(doc);
            }
          });
          return;
        }
        return done(false, "wrong whilst splicing. users l.280");
      });
    },

    /*
    Ask users to review the challenge they've just done.
    @param  {Object}   idChallenge [id : _idChallenge (Object),idChallenged (Object),idChallenger (Object)]
    @param  {Function} done        [description]
    @return {[type]}               [description]
     */
    askRate: function(data, done) {
      var query;
      query = [data._idChallenger, data._idChallenged];
      User.update({
        _id: {
          $in: query
        }
      }, {
        $addToSet: {
          challengeRate: data.id
        }
      }, {
        multi: true
      }).exec(function(err, user) {
        if (err) {
          mailer.cLog('Error at ' + __filename, err);
        }
        console.log(user);
        return done(true);
      });
    },
    userToRateChallenges: function(idUser, done) {
      User.findById(idUser).populate("challengeRate").exec(function(err, data) {
        if (err) {
          return done(err);
        }
        return done(data);
      });
    },
    getLeaderboards: function(type, scale, done) {
      var query, self, where;
      self = this;
      if (type === "score") {
        if (scale === 'global') {
          query = '-globalScore';
          where = 'globalScore';
        } else {
          query = scale + "Rank";
          where = query;
        }
        return User.find({}).sort(query).where(where).gte(0).select("-notifications -friends -challengeRateHistoric").exec(function(err, challengers) {
          if (err) {
            mailer.cLog('Error at ' + __filename, err);
          }
          return done(challengers);
        });
      }
    }
  };

}).call(this);
